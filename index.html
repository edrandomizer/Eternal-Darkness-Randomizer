<!DOCTYPE html>
<html>

<head>
    <title>Eternal Darkness Random</title>
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">

	<style type="text/css">

	    input {
	        margin-top: 10px;
	    }
	</style>
</head>

<body>
    <div>
		<input type="file">
    </div>
    <div id="message"></div>
    <div id="options">
		<input type="checkbox" id="text_control"  checked="checked" />Randomize text<br />
		<input type="checkbox" id="zombie_control" checked="checked" />Randomize zombie alignment<br />
    </div>

    <script type="text/javascript">
		let input = document.querySelector('input');

		function writeString(buffer, s, offset){
			var data=new Uint8Array(buffer);
			var i=0;
			while(i<s.length){
				data[offset+i]=s.charCodeAt(i);
				i++;
			}
			data[offset+i]=0;
		}

		function writeBuffer(src, dest, offset){
			var ds=new Uint8Array(src);
			var dd=new Uint8Array(dest);

			dd.set(ds, offset);

		}

		function download(iso, filename="ED.modded.iso"){
			if(iso.toBuffer){
				iso=iso.toBuffer();
			}
			if(iso.buffer){
				iso=iso.buffer;
			}
			const blob=new Blob([iso]);
			const ele=document.createElement('a');
			const url = URL.createObjectURL(blob);
			ele.setAttribute('href', url);
			ele.setAttribute('download', filename);
			ele.style.visibility = 'hidden';
			document.body.appendChild(ele);
			ele.click();
			document.body.removeChild(ele);
		}

		function decompress(compressed){
			var compLength=compressed.length*compressed.BYTES_PER_ELEMENT;
			var buf = Module._malloc(compLength+8);
			Module.HEAPU8.set(compressed, buf+8);

			var outLength=Module.ccall('DecompressSK_ASC', 'number', ['number', 'number', 'number'], [buf+8, compLength, buf]);

			var outp=Module.getValue(buf, 'i32');
			Module._free(buf);

			var view=Module.HEAPU8.slice(outp, outp+outLength);
			Module._free(outp);
			return view.buffer;
		}

		function decompressText(compressed, decompressedLength){
			var buf = Module._malloc(compressed.length*compressed.BYTES_PER_ELEMENT);
			Module.HEAPU8.set(compressed, buf);
			var out = Module._malloc(decompressedLength*2);

			var r=Module.ccall('DecompressText', 'number', ['number', 'number', 'number'], [buf, decompressedLength, out]);
			var view=Module.HEAPU8.slice(out+0x1a, out+decompressedLength*2+0x1a);
			Module._free(buf);
			Module._free(out);
			var od=new Uint8Array(view);
			view=view.slice(0, od.indexOf(0));
			return String.fromCharCode.apply(String, view);
		}

		class DOLSection {
			constructor(buffer, addr, type){
				this.buffer=buffer;
				this.addr=addr;
				this.type=type;

				this.data=new DataView(buffer);
			}

			append(buffer){
				var oldBuf=this.buffer;
				this.buffer=new ArrayBuffer(oldBuf.byteLength+buffer.byteLength);

				var ia=new Uint8Array(this.buffer);
				ia.set(new Uint8Array(oldBuf), 0);
				ia.set(new Uint8Array(buffer), oldBuf.byteLength);

				this.data=new DataView(this.buffer);
			}

			getSize(){
				return this.buffer.byteLength;
			}

			replace(buffer){
				this.buffer=buffer;
			}

			inBounds(addr, width=1){
				return (addr>=this.addr && addr+width<=this.addr+this.getSize());
			}

			dataSlice(addr, width){
				return this.buffer.slice(addr-this.addr, (addr-this.addr)+width);
			}

			read4(addr){
				return this.data.getUint32(addr-this.addr, false);
			}

			read2(addr){
				return this.data.getUint16(addr-this.addr, false);
			}

			read(addr){
				return this.data.getUint8(addr-this.addr, false);
			}

			write4(addr, value){
				if(value<0){
					this.data.setInt32(addr-this.addr, value, false);
				}else{
					this.data.setUint32(addr-this.addr, value, false);
				}
			}

			write2(addr, value){
				if(value<0){
					this.data.setInt16(addr-this.addr, value, false);
				}else{
					this.data.setUint16(addr-this.addr, value, false);
				}
			}

			write(addr, value){
				if(value<0){
					this.data.setInt8(addr-this.addr, value, false);
				}else{
					this.data.setUint8(addr-this.addr, value, false);
				}
			}

		}

		class DOL {

			constructor(buffer){
				const raw=new DataView(buffer);

				this.textCount=7;
				this.dataCount=11;

				var offset=0;

				var textPositions=[];

				for(var i=0; i<this.textCount; i++){
					textPositions.push(raw.getUint32((offset++)*4, false));
				}

				var dataPositions=[];

				for(var i=0; i<this.dataCount; i++){
					dataPositions.push(raw.getUint32((offset++)*4, false));
				}

				var textMem=[];

				for(var i=0; i<this.textCount; i++){
					textMem.push(raw.getUint32((offset++)*4, false));
				}

				var dataMem=[];

				for(var i=0; i<this.dataCount; i++){
					dataMem.push(raw.getUint32((offset++)*4, false));
				}

				var textSize=[];

				for(var i=0; i<this.textCount; i++){
					textSize.push(raw.getUint32((offset++)*4, false));
				}

				var dataSize=[];

				for(var i=0; i<this.dataCount; i++){
					dataSize.push(raw.getUint32((offset++)*4, false));
				}

				this.stackAddr=raw.getUint32((offset++)*4, false);
				this.stackSize=raw.getUint32((offset++)*4, false);
				this.entryPoint=raw.getUint32((offset++)*4, false);

				this.sections=[];

				for(var i=0; i<this.textCount; i++){
					if(textPositions[i]!=0 || textMem[i]!=0 || textSize[i]!=0){
						this.sections.push(new DOLSection(buffer.slice(textPositions[i], textPositions[i]+textSize[i]), textMem[i], "text"));
					}
				}

				for(var i=0; i<this.dataCount; i++){
					if(dataPositions[i]!=0 || dataMem[i]!=0 || dataSize[i]!=0){
						this.sections.push(new DOLSection(buffer.slice(dataPositions[i], dataPositions[i]+dataSize[i]), dataMem[i], "data"));
					}
				}

			}

			prepareInjectionSection(addr){//TODO automatic injection address

				if(addr%4!=0){
					throw("Section must be 4 byte aligned");
				}

				this.injectionSection=this.getSection(addr);
				this.injectionBase=addr;

				//Adding a new section breaks everything
				//this.injectionSection=new DOLSection(new ArrayBuffer(0), addr, "text");
				//this.sections.push(this.injectionSection);
			}

			calculateRelocation(current, base){
				var addr=current&0x3FFFFFF;
				var bAddr=base&0x3FFFFFF;

				return (current&0xFC000000)|((current-base)&0x3FFFFFF);
			}

			inject(addr, code, relocations=[]){//TODO relocations
				if(!this.injectionSection){
					throw("Must prepare injection section before injection");
				}

				if(addr % 4!=0){
					throw("Must inject at a 4 byte alignment");
				}

				const branchOpcode=0x48000000;

				var section=this.getSection(addr, 4);

				var oldInstruction=section.read4(addr);

				var branchOffset=(this.injectionBase-addr);
				var branchInstruction=branchOpcode|(branchOffset&0x03FFFFFF);

				var returnOffset=-(branchOffset+code.byteLength);
				var branchReturn=branchOpcode|(returnOffset&0x03FFFFFF);

				var newBuf=new ArrayBuffer(code.byteLength+8);
				new Uint8Array(newBuf).set(new Uint8Array(code), 0);
				var nd=new DataView(newBuf);

				nd.setUint32(code.byteLength, oldInstruction, false);
				nd.setUint32(code.byteLength+4, branchReturn, false);

				for(var reloc of relocations){
					var current=nd.getUint32(reloc, false);
					var inst=this.calculateRelocation(current, this.injectionBase+reloc);
					nd.setUint32(reloc, inst, false);
				}

				new Uint8Array(this.injectionSection.buffer).set(new Uint8Array(newBuf), this.injectionBase-this.injectionSection.addr);

				this.injectionBase+=newBuf.byteLength;

				section.write4(addr, branchInstruction);

			}

			getSize(){
				var size=0x100;
				for(var section of this.sections){
					size+=section.getSize();
				}
				return size;
			}

			getSection(addr, width){
				for(var section of this.sections){
					if(section.inBounds(addr, width)){
						return section;
					}
				}
				throw("address out of bounds at "+addr.toString(16));
			}

			dataSlice(addr, width){
				return this.getSection(addr, width).dataSlice(addr, width);
			}

			read4(addr){
				return this.getSection(addr, 4).read4(addr, 4);
			}

			read2(addr){
				return this.getSection(addr, 2).read2(addr);
			}

			read(addr){
				return this.getSection(addr, 1).read(addr);
			}

			write4(addr, value){
				return this.getSection(addr, 1).write4(addr, value);
			}

			write2(addr, value){
				return this.getSection(addr, 1).write2(addr, value);
			}

			write(addr, value){
				return this.getSection(addr, 1).write(addr, value);
			}

			writeToBuffer(buffer, offset){
				var data=new DataView(buffer);
				var ints=new Uint8Array(buffer);
				var tCount=0;
				var dCount=0;
				var pos=0x100;

				for(var section of this.sections){

					var eOffset=(section.type == "text" ? tCount++ : dCount++)*4;

					var tOffset=(section.type=="text" ? 0 : this.textCount*4);


					data.setUint32(offset+tOffset+eOffset, pos, false);
					data.setUint32(offset+tOffset+eOffset+0x48, section.addr, false);
					var size=section.getSize();

					data.setUint32(offset+tOffset+eOffset+0x90, size, false);

					ints.set(new Uint8Array(section.buffer), offset+pos);

					pos+=size;
				}

				data.setUint32(offset+0xD8, this.stackAddr, false);
				data.setUint32(offset+0xDC, this.stackSize, false);
				data.setUint32(offset+0xE0, this.entryPoint, false);
				return offset+pos;
			}

		}

		class GPK{
			constructor(buffer){

				if(!buffer){
					this.entries=[];
					this.entryCount=0;
					return;
				}
				const raw=new DataView(buffer);

				if(raw.getUint32(4, false)!=0x6b5){
					throw "Incorrect magic number in gpk";
				}

				this.entryCount=raw.getUint32(0, false);

				this.entries=[];

				var i=0;
				while(i<this.entryCount){
					var offset=raw.getUint32(8+i*8, false);
					var size=raw.getUint32(12+i*8, false);

					if(offset!=0 && size!=0){
						if(raw.getUint32(offset+4, false)==0xfb90){
							var sCount=raw.getUint32(offset, false);
							var j=0;
							var strings=[];
							while(j<sCount){
								var sOffset=raw.getUint32(offset+8+j*8, false);
								var sSize=raw.getUint32(offset+12+j*8, false);

								if(sSize!=0 && sOffset!=0){
									strings[j]=buffer.slice(offset+sOffset, offset+sOffset+sSize);
								}

								j++;
							}
							this.entries[i]=strings;
						}else{
							this.entries[i]=buffer.slice(offset, offset+size);
						}
					}
					i++;
				}
			}

			getSize(){
				var size=8+8*this.entryCount;
				for(var ent of this.entries){
					if(Array.isArray(ent)){
						size+=8+ent.length*8;
						for(var s of ent){
							if(s){
								size+=s.byteLength;
							}
						}
					}else if(ent){
						size+=ent.byteLength;
					}
				}
				return size;
			}

			toBuffer(){

				this.entryCount=this.entries.length;

				var out=new ArrayBuffer(this.getSize());
				var d=new DataView(out);
				var u=new Uint8Array(out);

				d.setUint32(0, this.entryCount, false);
				d.setUint32(4, 0x6b5, false);

				var curOff=8+this.entryCount*8;

				var i=0;
				while(i<this.entryCount){
					var ent=this.entries[i];
					if(!ent){
						d.setUint32(8+i*8, 0, false);
						d.setUint32(12+i*8, 0, false);
					}else if(Array.isArray(ent)){
						d.setUint32(8+i*8, curOff, false);
						d.setUint32(12+i*8, 8, false);

						var tBase=curOff;
						curOff+=8+ent.length*8;

						d.setUint32(tBase, ent.length, false);
						d.setUint32(tBase+4, 0xfb90, false);

						var j=0;
						while(j<ent.length){
							if(ent[j]){
								d.setUint32(tBase+8+j*8, curOff-tBase, false);
								d.setUint32(tBase+12+j*8, ent[j].byteLength, false);

								u.set(new Uint8Array(ent[j]), curOff);
								curOff+=ent[j].byteLength;

							}else{
								d.setUint32(tBase+8+j*8, 0, false);
								d.setUint32(tBase+12+j*8, 0, false);
							}
							j++;
						}
					}else{
						d.setUint32(8+i*8, curOff, false);
						d.setUint32(12+i*8, ent.byteLength, false);

						u.set(new Uint8Array(ent), curOff);
						curOff+=ent.byteLength;
					}
					i++;
				}
				return out;
			}

		}

		class File{
			constructor(buffer){
				this.buffer=buffer;
				this.data=new DataView(buffer);
			}

			read4(offset){
				return this.data.getUint32(offset, false);
			}

			read2(offset){
				return this.data.getUint16(offset, false);
			}

			read(offset){
				return this.data.getUint8(offset, false);
			}

			write4(offset, value){
				if(value<0){
					this.data.setInt32(offset, value, false);
				}else{
					this.data.setUint32(offset, value, false);
				}
			}

			write2(offset, value){
				if(value<0){
					this.data.setInt16(offset, value, false);
				}else{
					this.data.setUint16(offset, value, false);
				}
			}

			write(offset, value){
				if(value<0){
					this.data.setInt8(offset, value, false);
				}else{
					this.data.setUint8(offset, value, false);
				}
			}

			replace(buffer){
				this.buffer=buffer;
				this.data=new DataView(buffer);
			}

			decompressSKASC(){
				if(this.read4(0)==0x2a534b5f && this.read4(4)==0x4153432a){//*SK_ASC*
					this.replace(decompress(new Uint8Array(this.buffer)));
				}
			}

		}

		class FST{
			constructor(buffer, offset, size){

				const raw=new DataView(buffer);

				var eOffset=0;

				var entries=[];

				var loadEntry={name:"loading", type:"dir", entries:[], parent:null, next:1};

				var curDir=loadEntry;

				while(eOffset<size){
					while(curDir && entries.length>=curDir.next){
						curDir=curDir.parent;
					}

					if(curDir==null){
						break;
					}

					var first=raw.getUint32(offset+eOffset, false);
					var type=(first &0xFF000000)>>24;
					var str=first&0xFFFFFF;

					var offsetOrParent=raw.getUint32(offset+eOffset+4, false);
					var fileLength=raw.getUint32(offset+eOffset+8, false);

					if(type==0){
						var entry={name: str, type: "file", offset: offsetOrParent, len: fileLength, file: null};
						curDir.entries.push(entry);
						entries.push(entry)
					}else if(type==1){
						var entry={name: str, type: "dir", entries:[], parent: entries.length==0 ? null : entries[offsetOrParent], next:fileLength};

						curDir.entries.push(entry);
						entries.push(entry);
						curDir=entry;
					}else{
						throw("Unexpected file type in FST");
					}

					eOffset+=12;
				}

				if(eOffset>=size){
					throw("Unexected FST end");
				}

				for(var ent in entries){
					var index=entries[ent].name;
					var str="";
					var cur=0;
					while((cur=raw.getUint8(offset+eOffset+index, false))!=0){
						str+=String.fromCharCode(cur);
						index++;
					}
					entries[ent].name=str;

					if(entries[ent].type=="file"){
						entries[ent].file=new File(buffer.slice(entries[ent].offset, entries[ent].offset+entries[ent].len));

						entries[ent].align=32*1024;

						while(entries[ent].offset % entries[ent].align!=0){
							entries[ent].align/=2;
						}
					}
				}

				this.root=loadEntry.entries[0];
				this.root.name="";
			}

			getFrom(name, entry){
				if(typeof(name)=="string"){
					name=name.split("/");
				}
				for(var ent of entry.entries){
					if(ent.name==name[0]){
						if(name.length==1){
							return ent;
						}else if(ent.type=="dir"){
							return this.getFrom(name.slice(1), ent);
						}else{
							throw("Tried to traverse into file "+ name[0]);
						}
					}
				}
				throw("Could not find file");
			}

			getEntry(name){
				if(typeof(name)=="string" && name[0]=="/"){
					name=name.substr(1);
				}
				return this.getFrom(name, this.root);
			}

			getFile(name){
				var e=this.getEntry(name);
				if(e.type=="dir"){
					throw("Tried to getFile for directory"+name);
				}
				return e.file;
			}

			countNestedEntries(entry){
				if(entry.type == "file"){
					return 1;
				}
				var count=1;

				for(var ent of entry.entries){
					count+=this.countNestedEntries(ent);
				}
				return count;
			}

			getNestedStringLength(entry){
				var count=entry.name.length+1;
				if(entry.type=="file"){
					return count;
				}
				for(var ent of entry.entries){
					count+=this.getNestedStringLength(ent);
				}
				return count;
			}

			getSize(){
				var size=this.countNestedEntries(this.root)*12;
				var stringSize=this.getNestedStringLength(this.root);

				return size+stringSize;
			}

			writeEntryToBuffer(buffer, offset, entryOffset, stringsBase, stringsOffset, fileOffset, parentOffset, entry){
				var initial=entryOffset;
				var data=new DataView(buffer);

				var filesWritten=[];

				var first=stringsOffset+((entry.type=="dir" ? 1 : 0)<<24);
				data.setUint32(offset+(entryOffset*12), first, false);
				writeString(buffer, entry.name, offset+stringsBase+stringsOffset);
				stringsOffset+=entry.name.length+1;

				if(entry.type=="file"){

					var existing=null;

					for(var check of filesWritten){
						if(check[0]===entry.file.buffer && check[1] % entry.align==0){
							existing=check;
							break;
						}
					}

					if(existing){
						data.setUint32(offset+(entryOffset*12)+4, existing[1], false);
						data.setUint32(offset+(entryOffset*12)+8, existing[2], false);
					}else{

						if(fileOffset % entry.align!=0){
							fileOffset=fileOffset+entry.align - (fileOffset % entry.align);
						}

						data.setUint32(offset+(entryOffset*12)+4, fileOffset, false);
						data.setUint32(offset+(entryOffset*12)+8, entry.file.buffer.byteLength, false);

						writeBuffer(entry.file.buffer, buffer, fileOffset);

						filesWritten.push([entry.file.buffer, fileOffset, entry.file.buffer.byteLength]);

						fileOffset+=entry.file.buffer.byteLength;
					}

					entryOffset++;
				}else{
					data.setUint32(offset+(entryOffset*12)+4, parentOffset, false);

					entryOffset++;
					for(var ent of entry.entries){
						var n=this.writeEntryToBuffer(buffer, offset, entryOffset, stringsBase, stringsOffset, fileOffset, initial, ent);
						entryOffset=n[0];
						stringsOffset=n[1];
						fileOffset=n[2];
					}

					data.setUint32(offset+(initial*12)+8, entryOffset, false);
				}
				return [entryOffset, stringsOffset, fileOffset];
			}

			writeToBuffer(buffer, offset){
				var n=this.writeEntryToBuffer(buffer, offset, 0, this.countNestedEntries(this.root)*12, 0, offset+this.getSize(), 0, this.root);
				return n[2];
			}

		}

		class Header{
			constructor(buffer){

				var raw=new DataView(buffer);

				if(raw.getUint32(0x1c, false)!=0xc2339f3d){
					throw("Bad magic number");
				}

				this.apploaderSize=raw.getUint32(0x2440+0x14, false);

				this.buffer=buffer.slice(0, 0x2440+this.apploaderSize);
				this.data=new DataView(this.buffer);
				this.dolOffset=this.data.getUint32(0x420, false);
				this.fstOffset=this.data.getUint32(0x424, false);
				this.fstSize=this.data.getUint32(0x428, false);
			}

			rebuild(iso){

				this.dolOffset=this.buffer.byteLength;
				this.data.setUint32(0x420, this.dolOffset, false);

				this.fstOffset=this.dolOffset+iso.dol.getSize();
				this.data.setUint32(0x424, this.fstOffset, false);

				this.fstSize=iso.fst.getSize();
				this.data.setUint32(0x428, this.fstSize, false);
				this.data.setUint32(0x42C, this.fstSize, false);
			}

			writeToBuffer(buffer, offset){
				writeBuffer(this.buffer, buffer, offset);
				return offset+this.dolOffset;
			}
		}

		class GCISO {

			constructor(buffer){

				this.imageSize=1459978240;

				if(buffer.byteLength!=this.imageSize){
					console.log("Bad file size, are you sure this is a gamecube iso?");
				}

				this.header=new Header(buffer);

				this.dol=new DOL(buffer.slice(this.header.dolOffset));

				this.fst=new FST(buffer, this.header.fstOffset, this.header.fstSize);

			}

			toBuffer(){

				var ret=new ArrayBuffer(this.imageSize);
				this.header.rebuild(this);
				var c=this.header.writeToBuffer(ret, 0);
				c=this.dol.writeToBuffer(ret, c);

				c=this.fst.writeToBuffer(ret, c);
				console.log("Free space: "+(this.imageSize-c));
				return ret;
			}
		}

		var iso=null;
		var manualMode=false;

		input.addEventListener('change', () => {
			let files = input.files;

			if (files.length == 0) return;

			const file = files[0];

			let reader = new FileReader();
			displayMessage("Loading");
			reader.onload = (e) => {
				const file = e.target.result;

				displayMessage("Analyzing");
				window.setTimeout(function(){
					var niso=new GCISO(file);

					if(manualMode){
						iso=niso;
						displayMessage("Ready");
					}else{
						displayMessage("Patching");
						window.setTimeout(function(){
							prepare(niso);
							bypassCompression(niso, function(){
								if(document.getElementById("text_control").checked){
									roomTextShuffle(niso);
								}
								if(document.getElementById("zombie_control").checked){
									randomiseZombieAlignment(niso, [null, null, null, [0, 12]]);
								}
								displayMessage("Rebuilding");
								window.setTimeout(function(){
									var buf=niso.toBuffer();
									displayMessage("Preparing download");
									download(buf);
								}, 1);
							});
						}, 1);
					}
				}, 1);
			};

			reader.onerror = (e) => alert(e.target.error.name);

			reader.readAsArrayBuffer(file);
		});

		function decompressAll(dir){
			for(var entry of dir.entries){
				if(entry.type=="dir"){
					decompressAll(entry);
				}else if(entry.type=="file"){
					var file=entry.file;
					if(file.read4(0)==0x2a534b5f && file.read4(4)==0x4153432a){//*SK_ASC*
						console.log("Decompressing "+entry.name);
						file.decompressSKASC();
					}
				}
			}
		}

		function displayMessage(message){
			document.getElementById("message").innerHTML=message;
		}

		function prepare(iso){
			iso.dol.prepareInjectionSection(0x802fd8e0);
		}

		function loadAsset(url, onLoad){
			var xhr = new XMLHttpRequest();

			xhr.addEventListener('load', function(){
				if (xhr.status == 200){
					var fileReader = new FileReader();
					fileReader.onload = function(event) {
					    arrayBuffer = event.target.result;

						onLoad(event.target.result);
					};
					fileReader.readAsArrayBuffer(xhr.response);
				}else{
					console.log("Could not load "+url);
				}
			});
			xhr.addEventListener('error', function(e){
				console.log("Error when loading "+url);
				console.log(e);
			});
			xhr.open('GET', url);
			xhr.responseType = 'blob';
			xhr.send(null);
		}

		function bypassCompression(iso, continuation){

			loadAsset("./compressionBypass.bin", function(code){
				iso.dol.inject(0x80147e4c, code, [0x14, 0x34, 0x64, 0x9c, 0xb0]);
				if(continuation){
					continuation();
				}
			});

		}

		function collectNpcTypes(iso){
			var res=[];

			var i=0;
			while(i<14){
				if(i==12){
					i++;
					continue;
				}
				var filename="Npcs"+i+".npc";

				var f=iso.fst.getFile(filename);

				var c=f.read4(4);

				var j=0;
				while(j<c){
					var type=f.read4(0x44+j*0x28).toString(16);

					if(!res[type]){
						res[type]=0;
					}
					res[type]++;

					j++;
				}
				i++;
			}
			return res;
		}

		function collectNpcTypesLevel(iso, level){
			var filename="Npcs"+level+".npc";
			var res=[]
			var f=iso.fst.getFile(filename);

			var c=f.read4(4);

			var j=0;
			console.log(c);
			while(j<c){
				var type=f.read4(0x44+j*0x28).toString(16);

				if(!res[type]){
					res[type]=0;
				}
				res[type]++;

				j++;
			}
			return res;
		}

		function getNPC(f, type, index){

			const typeSizes=[0x28, 0x68, 0x2c, 0x34, 0x3c];

			var i=0;
			var offset=0x2c;
			while(i<type){
				offset+=f.read4(8+i*8);
				i++;
			}

			return f.buffer.slice(offset+index*typeSizes[type], offset+index*typeSizes[type]+typeSizes[type]);
		}

		function randomiseZombieAlignment(iso, skipList){


			var pious=iso.fst.getFile("Npcs1.npc");
			var lindsey=iso.fst.getFile("Npcs6.npc");

			var templates=[
				new Uint8Array(getNPC(pious, 0, 0).slice(8)),//m zombie
				new Uint8Array(getNPC(lindsey, 0, 0xe).slice(8)),// x zombie
				new Uint8Array(getNPC(lindsey, 0, 0x12).slice(8)),// u zombie
				new Uint8Array(getNPC(lindsey, 0, 9).slice(8)), // c zombie
			];

			var i=0;
			while(i<14){
				if(i==12){
					i++;
					continue;
				}
				var file=iso.fst.getFile("Npcs"+i+".npc");

				var c=file.read4(4);

				var j=0;
				while(j<c){
					var type=file.read2(0x44+j*0x28);
					if((type==0x8 //m zombie
					      || type==0x7 //x zombie
					      || type==0x6 //u zombie
					      || type==0x1) //c zombie
					    && (!skipList[i] || skipList[i].indexOf(j)===-1) ){

							var b=new Uint8Array(file.buffer);
							b.set(templates[Math.floor(Math.random()*4)], 0x34+j*0x28);
					 }
					j++;
				}

				i++;
			}


		}

		function roomTextShuffle(iso){

			var gpks=[];
			var newGpks=[];
			var entries=[];
			var pools=[];
			var cmps=[];

			var i=0;
			while(i<14){
				var filename="RmTxt"+("00"+i).slice(-2)+".cmp";

				var cmp=iso.fst.getFile(filename);
				cmp.decompressSKASC();

				cmps[i]=cmp;

				gpks[i]=new GPK(cmp.buffer);
				newGpks[i]=new GPK();

				for(var fi in gpks[i].entries){
					if(gpks[i].entries[fi]){
						for(var si in gpks[i].entries[fi]){
							if(gpks[i].entries[fi][si]){
								var d=new DataView(gpks[i].entries[fi][si]);
								var special=d.getUint32(0, false);
								if(!pools[special]){
									pools[special]=[];
								}
								if(!entries[fi]){
									entries[fi]=[];
								}
								if(!entries[fi][si]){
									entries[fi][si]=[];
								}
								pools[special].push([fi, si]);
								entries[fi][si].push(i);
							}
						}
					}
				}
				i++;
			}

			for(var special in pools){
				var pc=pools[special].slice(0);
				pc.sort(() => { return Math.random()-0.5;});

				for(var rIndex in pools[special]){
					var source=pc[rIndex];
					var dest=pools[special][rIndex];

					var sourceFi=source[0];
					var sourceSi=source[1];

					var destFi=dest[0];
					var destSi=dest[1];

					var data=gpks[entries[sourceFi][sourceSi][0]].entries[sourceFi][sourceSi];

					if(!data){
						console.log(sourceFi, sourceSi, entries[sourceFi][sourceSi][0]);

					}

					for(var de of entries[destFi][destSi]){
						if(!newGpks[de].entries[destFi]){
							newGpks[de].entries[destFi]=[];
						}
						newGpks[de].entries[destFi][destSi]=data;
					}

				}
			}
			for(var file in cmps){
				cmps[file].replace(newGpks[file].toBuffer());
			}

		}

		function textLookup(file, i1, i2){
			if(file.read4(4)!=0x6b5){
				throw "Doesn't look like an archive file, did you forget to decompress?";
			}

			if(file.read4(0)<=i1){
				throw "First index out of bounds";
			}

			var iOffset=file.read4(8+i1*8);
			if(iOffset==0){
				throw "First index empty";
			}

			if(file.read4(iOffset+4)!=0xfb90){
				throw "Not a text archive";
			}

			if(file.read4(iOffset)<=i2){
				throw "Second index out of bounds";
			}

			var eOffset=file.read4(iOffset+8+i2*8);
			var size=file.read4(iOffset+12+i2*8);
			if(eOffset==0 || size==0){
				throw "Entry empty";
			}

			var buf=file.buffer.slice(iOffset+eOffset+4, iOffset+eOffset+size+4);

			return decompressText(new Uint8Array(buf), size-4);
		}

		function stripFMV(iso){
			const changeTo=0;

			const sourceA=iso.fst.getFile("fmv/fmv"+(("0000" + changeTo).slice(-4))+".aud");
			const sourceH=iso.fst.getFile("fmv/fmv"+(("0000" + changeTo).slice(-4))+".h4m");

			var i=1;

			while(i<64){
				try{
					var fileA=iso.fst.getFile("fmv/fmv"+(("0000" + i).slice(-4))+".aud");
					fileA.replace(sourceA.buffer);
				}catch(err){}//TODO proper fs errors

				try{
					var fileH=iso.fst.getFile("fmv/fmv"+(("0000" + i).slice(-4))+".h4m");
					fileH.replace(sourceH.buffer);
				}catch(err){}
				i++;
			}
		}

    </script>
    <script src="./skasc.js"></script>
</body>

</html>
