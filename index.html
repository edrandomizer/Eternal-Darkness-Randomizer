<!DOCTYPE html>
<html>

<head>
    <title>Eternal Darkness Random</title>
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">

	<style type="text/css">

	    input {
	        margin-top: 10px;
	    }
	</style>
</head>

<body>
    <div>
		<input type="file">
    </div>
    <div id="message"></div>
    <div id="options">
		<input type="checkbox" id="text_control"  checked="checked" />Randomize text<br />
		<input type="checkbox" id="enemy_control" checked="checked" />Randomize enemies<br />
		<input type="checkbox" id="rune_control" />Randomize rune locations<br />
		<input type="input" id="seed" placeholder="Seed (leave blank for random)"></br>
    </div>

    <script type="text/javascript">
		let input = document.querySelector('input');

		function writeString(buffer, s, offset){
			var data=new Uint8Array(buffer);
			var i=0;
			while(i<s.length){
				data[offset+i]=s.charCodeAt(i);
				i++;
			}
			data[offset+i]=0;
		}

		function writeBuffer(src, dest, offset){
			var ds=new Uint8Array(src);
			var dd=new Uint8Array(dest);

			dd.set(ds, offset);

		}

		function download(iso, filename="download.file"){
			if(iso.toBuffer){
				iso=iso.toBuffer();
			}
			if(iso.buffer){
				iso=iso.buffer;
			}
			const blob=new Blob([iso]);
			const ele=document.createElement('a');
			const url = URL.createObjectURL(blob);
			ele.setAttribute('href', url);
			ele.setAttribute('download', filename);
			ele.style.visibility = 'hidden';
			document.body.appendChild(ele);
			ele.click();
			document.body.removeChild(ele);
		}

		function decompress(compressed){
			var compLength=compressed.length*compressed.BYTES_PER_ELEMENT;
			var buf = Module._malloc(compLength+8);
			Module.HEAPU8.set(compressed, buf+8);

			var outLength=Module.ccall('DecompressSK_ASC', 'number', ['number', 'number', 'number'], [buf+8, compLength, buf]);

			var outp=Module.getValue(buf, 'i32');
			Module._free(buf);

			var view=Module.HEAPU8.slice(outp, outp+outLength);
			Module._free(outp);
			return view.buffer;
		}

		function decompressText(compressed, decompressedLength=0){
			if(decompressedLength==0){
				decompressedLength=compressed.length*compressed.BYTES_PER_ELEMENT;
			}
			var buf = Module._malloc(compressed.length*compressed.BYTES_PER_ELEMENT);
			Module.HEAPU8.set(compressed, buf);
			var out = Module._malloc(decompressedLength*2);

			var r=Module.ccall('DecompressText', 'number', ['number', 'number', 'number'], [buf, decompressedLength, out]);
			var view=Module.HEAPU8.slice(out+0x1a, out+decompressedLength*2+0x1a);
			Module._free(buf);
			Module._free(out);
			var od=new Uint8Array(view);
			view=view.slice(0, od.indexOf(0));
			return String.fromCharCode.apply(String, view);
		}

		class DOLSection {
			constructor(buffer, addr, type){
				this.buffer=buffer;
				this.addr=addr;
				this.type=type;

				this.data=new DataView(buffer);
			}

			append(buffer){
				var oldBuf=this.buffer;
				this.buffer=new ArrayBuffer(oldBuf.byteLength+buffer.byteLength);

				var ia=new Uint8Array(this.buffer);
				ia.set(new Uint8Array(oldBuf), 0);
				ia.set(new Uint8Array(buffer), oldBuf.byteLength);

				this.data=new DataView(this.buffer);
			}

			getSize(){
				return this.buffer.byteLength;
			}

			replace(buffer){
				this.buffer=buffer;
			}

			inBounds(addr, width=1){
				return (addr>=this.addr && addr+width<=this.addr+this.getSize());
			}

			dataSlice(addr, width){
				return this.buffer.slice(addr-this.addr, (addr-this.addr)+width);
			}

			read4(addr){
				return this.data.getUint32(addr-this.addr, false);
			}

			read2(addr){
				return this.data.getUint16(addr-this.addr, false);
			}

			read(addr){
				return this.data.getUint8(addr-this.addr, false);
			}

			write4(addr, value){
				if(value<0){
					this.data.setInt32(addr-this.addr, value, false);
				}else{
					this.data.setUint32(addr-this.addr, value, false);
				}
			}

			write2(addr, value){
				if(value<0){
					this.data.setInt16(addr-this.addr, value, false);
				}else{
					this.data.setUint16(addr-this.addr, value, false);
				}
			}

			write(addr, value){
				if(value<0){
					this.data.setInt8(addr-this.addr, value, false);
				}else{
					this.data.setUint8(addr-this.addr, value, false);
				}
			}

		}

		class DOL {

			constructor(buffer){
				const raw=new DataView(buffer);

				this.textCount=7;
				this.dataCount=11;

				var offset=0;

				var textPositions=[];

				for(var i=0; i<this.textCount; i++){
					textPositions.push(raw.getUint32((offset++)*4, false));
				}

				var dataPositions=[];

				for(var i=0; i<this.dataCount; i++){
					dataPositions.push(raw.getUint32((offset++)*4, false));
				}

				var textMem=[];

				for(var i=0; i<this.textCount; i++){
					textMem.push(raw.getUint32((offset++)*4, false));
				}

				var dataMem=[];

				for(var i=0; i<this.dataCount; i++){
					dataMem.push(raw.getUint32((offset++)*4, false));
				}

				var textSize=[];

				for(var i=0; i<this.textCount; i++){
					textSize.push(raw.getUint32((offset++)*4, false));
				}

				var dataSize=[];

				for(var i=0; i<this.dataCount; i++){
					dataSize.push(raw.getUint32((offset++)*4, false));
				}

				this.stackAddr=raw.getUint32((offset++)*4, false);
				this.stackSize=raw.getUint32((offset++)*4, false);
				this.entryPoint=raw.getUint32((offset++)*4, false);

				this.sections=[];

				for(var i=0; i<this.textCount; i++){
					if(textPositions[i]!=0 || textMem[i]!=0 || textSize[i]!=0){
						this.sections.push(new DOLSection(buffer.slice(textPositions[i], textPositions[i]+textSize[i]), textMem[i], "text"));
					}
				}

				for(var i=0; i<this.dataCount; i++){
					if(dataPositions[i]!=0 || dataMem[i]!=0 || dataSize[i]!=0){
						this.sections.push(new DOLSection(buffer.slice(dataPositions[i], dataPositions[i]+dataSize[i]), dataMem[i], "data"));
					}
				}

			}

			prepareInjectionSection(addr){//TODO automatic injection address

				if(addr%4!=0){
					throw("Section must be 4 byte aligned");
				}

				this.injectionSection=this.getSection(addr);
				this.injectionBase=addr;

				//Adding a new section breaks everything
				//this.injectionSection=new DOLSection(new ArrayBuffer(0), addr, "text");
				//this.sections.push(this.injectionSection);
			}

			calculateRelocation(current, base){
				var addr=current&0x3FFFFFF;
				var bAddr=base&0x3FFFFFF;

				return (current&0xFC000000)|((current-base)&0x3FFFFFF);
			}

			inject(addr, code, relocations=[]){//TODO relocations
				if(!this.injectionSection){
					throw("Must prepare injection section before injection");
				}

				if(addr % 4!=0){
					throw("Must inject at a 4 byte alignment");
				}

				const branchOpcode=0x48000000;

				var section=this.getSection(addr, 4);

				var oldInstruction=section.read4(addr);

				var branchOffset=(this.injectionBase-addr);
				var branchInstruction=branchOpcode|(branchOffset&0x03FFFFFF);

				var returnOffset=-(branchOffset+code.byteLength);
				var branchReturn=branchOpcode|(returnOffset&0x03FFFFFF);

				var newBuf=new ArrayBuffer(code.byteLength+8);
				new Uint8Array(newBuf).set(new Uint8Array(code), 0);
				var nd=new DataView(newBuf);

				nd.setUint32(code.byteLength, oldInstruction, false);
				nd.setUint32(code.byteLength+4, branchReturn, false);

				for(var reloc of relocations){
					var current=nd.getUint32(reloc, false);
					var inst=this.calculateRelocation(current, this.injectionBase+reloc);
					nd.setUint32(reloc, inst, false);
				}

				new Uint8Array(this.injectionSection.buffer).set(new Uint8Array(newBuf), this.injectionBase-this.injectionSection.addr);

				this.injectionBase+=newBuf.byteLength;

				section.write4(addr, branchInstruction);

			}

			getSize(){
				var size=0x100;
				for(var section of this.sections){
					size+=section.getSize();
				}
				return size;
			}

			getSection(addr, width){
				for(var section of this.sections){
					if(section.inBounds(addr, width)){
						return section;
					}
				}
				throw("address out of bounds at "+addr.toString(16));
			}

			dataSlice(addr, width){
				return this.getSection(addr, width).dataSlice(addr, width);
			}

			read4(addr){
				return this.getSection(addr, 4).read4(addr, 4);
			}

			read2(addr){
				return this.getSection(addr, 2).read2(addr);
			}

			read(addr){
				return this.getSection(addr, 1).read(addr);
			}

			write4(addr, value){
				return this.getSection(addr, 1).write4(addr, value);
			}

			write2(addr, value){
				return this.getSection(addr, 1).write2(addr, value);
			}

			write(addr, value){
				return this.getSection(addr, 1).write(addr, value);
			}

			writeToBuffer(buffer, offset){
				var data=new DataView(buffer);
				var ints=new Uint8Array(buffer);
				var tCount=0;
				var dCount=0;
				var pos=0x100;

				for(var section of this.sections){

					var eOffset=(section.type == "text" ? tCount++ : dCount++)*4;

					var tOffset=(section.type=="text" ? 0 : this.textCount*4);


					data.setUint32(offset+tOffset+eOffset, pos, false);
					data.setUint32(offset+tOffset+eOffset+0x48, section.addr, false);
					var size=section.getSize();

					data.setUint32(offset+tOffset+eOffset+0x90, size, false);

					ints.set(new Uint8Array(section.buffer), offset+pos);

					pos+=size;
				}

				data.setUint32(offset+0xD8, this.stackAddr, false);
				data.setUint32(offset+0xDC, this.stackSize, false);
				data.setUint32(offset+0xE0, this.entryPoint, false);
				return offset+pos;
			}

		}

		class NPC{
			constructor(buffer){

				if(!buffer){
					this.entries=[[],[],[],[],[]];
					return;
				}
				const typeSizes=this.getTypeSizes();

				const raw=new DataView(buffer);

				if(raw.getUint32(0, false)!=0x2c){
					throw "Incorrect magic number in NPC file";
				}

				this.entries=[];

				var hOffset=4;
				var dOffset=0x2c;

				for(var type=0; type<5; type++){
					var count=raw.getUint32(hOffset, false);
					hOffset+=8;
					this.entries[type]=[];

					for(var i=0; i<count; i++){
						this.entries[type].push(buffer.slice(dOffset, dOffset+typeSizes[type]));

						dOffset+=typeSizes[type];
					}

				}
			}

			getTypeSizes(){
				return [0x28, 0x68, 0x2c, 0x34, 0x3c];
			}

			getSize(){
				var size=0x2c;
				const typeSizes=this.getTypeSizes();
				for(var i in this.entries){
					size+=typeSizes[i]*this.entries[i].length;
				}
				return size;
			}

			toBuffer(){
				const buf=new ArrayBuffer(this.getSize());

				const data=new DataView(buf);
				const arr=new Uint8Array(buf);

				const typeSizes=this.getTypeSizes();

				data.setUint32(0, 0x2c);

				var dOffset=0x2c;

				for(var i in this.entries){
					data.setUint32(4+i*8, this.entries[i].length, false);
					data.setUint32(8+i*8, this.entries[i].length*typeSizes[i], false);

					for(var ent of this.entries[i]){
						arr.set(new Uint8Array(ent), dOffset);
						dOffset+=typeSizes[i];
					}
				}

				return buf;
			}
		}

		class GPK{
			constructor(buffer){

				if(!buffer){
					this.entries=[];
					return;
				}
				const raw=new DataView(buffer);

				if(raw.getUint32(4, false)!=0x6b5){
					throw "Incorrect magic number in gpk";
				}

				var entryCount=raw.getUint32(0, false);

				this.entries=[];

				var i=0;
				while(i<entryCount){
					var offset=raw.getUint32(8+i*8, false);
					var size=raw.getUint32(12+i*8, false);

					if(offset!=0 && size!=0){
						if(raw.getUint32(offset+4, false)==0xfb90){
							var sCount=raw.getUint32(offset, false);
							var j=0;
							var strings=[];
							while(j<sCount){
								var sOffset=raw.getUint32(offset+8+j*8, false);
								var sSize=raw.getUint32(offset+12+j*8, false);

								if(sSize!=0 && sOffset!=0){
									strings[j]=buffer.slice(offset+sOffset, offset+sOffset+sSize);
								}

								j++;
							}
							this.entries[i]=strings;
						}else{
							this.entries[i]=buffer.slice(offset, offset+size);
						}
					}
					i++;
				}
			}

			getSize(){
				var size=8+8*this.entries.length;
				for(var ent of this.entries){
					if(Array.isArray(ent)){
						size+=8+ent.length*8;
						for(var s of ent){
							if(s){
								size+=s.byteLength;
							}
						}
					}else if(ent){
						size+=ent.byteLength;
					}
				}
				return size;
			}

			toBuffer(){

				var entryCount=this.entries.length;

				var out=new ArrayBuffer(this.getSize());
				var d=new DataView(out);
				var u=new Uint8Array(out);

				d.setUint32(0, entryCount, false);
				d.setUint32(4, 0x6b5, false);

				var curOff=8+entryCount*8;

				var i=0;
				while(i<entryCount){
					var ent=this.entries[i];
					if(!ent){
						d.setUint32(8+i*8, 0, false);
						d.setUint32(12+i*8, 0, false);
					}else if(Array.isArray(ent)){
						d.setUint32(8+i*8, curOff, false);
						d.setUint32(12+i*8, 8, false);

						var tBase=curOff;
						curOff+=8+ent.length*8;

						d.setUint32(tBase, ent.length, false);
						d.setUint32(tBase+4, 0xfb90, false);

						var j=0;
						while(j<ent.length){
							if(ent[j]){
								d.setUint32(tBase+8+j*8, curOff-tBase, false);
								d.setUint32(tBase+12+j*8, ent[j].byteLength, false);

								u.set(new Uint8Array(ent[j]), curOff);
								curOff+=ent[j].byteLength;

							}else{
								d.setUint32(tBase+8+j*8, 0, false);
								d.setUint32(tBase+12+j*8, 0, false);
							}
							j++;
						}
					}else{
						d.setUint32(8+i*8, curOff, false);
						d.setUint32(12+i*8, ent.byteLength, false);

						u.set(new Uint8Array(ent), curOff);
						curOff+=ent.byteLength;
					}
					i++;
				}
				return out;
			}

		}
		
		class LUA{
			constructor(buffer){
				if(!buffer){
					this.instructions=[];
					this.strings=[];
					this.numbers=[];
					this.maxStack=32;
					return;
				}
				
				const data=new DataView(buffer);

				if(data.getUint32(0, true)!=0x61754c1b){
					throw "Not a lua file";
				}
				
				if(data.getUint8(4, true)!=0x40){
					throw "Must be lua version 4";
				}

				if(data.getUint8(5, true)!=1 || data.getUint8(6, true)!=4 || data.getUint8(7, true)!=4
				   || data.getUint8(8, true)!=4 || data.getUint8(9, true)!=32 || data.getUint8(10, true)!=6
				   || data.getUint8(11, true)!=9 || data.getUint8(12, true)!=8){

					throw "Bad lua type";
				}
				
				if(data.getFloat64(13, true)!=3.14159265358979323846E8){
					throw "Mismatched floats";
				}
				
				this.maxStack=data.getUint32(35, true);
				
				const sCount=data.getUint32(47, true);
				
				var offset=51;
				this.strings=[];
				for(var i=0; i<sCount; i++){
					var size=data.getUint32(offset, true);
					offset+=4;
					var s=new Uint8Array(buffer.slice(offset, offset+size-1));
					s=String.fromCharCode.apply(String, s);
					this.strings.push(s);
					offset+=size;
				}
				
				
				const nCount=data.getUint32(offset, true);
				offset+=4;
				this.numbers=[];
				for(var i=0; i<nCount; i++){
					this.numbers.push(data.getFloat64(offset, true));
					offset+=8;
				}
				
				offset+=4;
				
				const iCount=data.getUint32(offset, true);

				offset+=4;
				this.instructions=[];
				for(var i=0; i<iCount; i++){
					this.instructions.push(data.getUint32(offset, true));
					offset+=4;
				}
			}
			
			buildInstruction(op, a, b){
				const opcodes=this.getOpcodes();
				
				var menemonics=opcodes.map((e)=>{return e[0]});
				
				var code=menemonics.indexOf(op.toUpperCase());

				if(code===-1){
					throw "Menemonic not recognised";
				}

				if(opcodes[code][1]=="NONE"){
					return code;
				}
				if(opcodes[code][1]=="U" || opcodes[1]=="L"){
					return code | (a<<6);
				}
				if(opcodes[code][1]=="S" || opcodes[1]=="J"){
					return code | ((a+0x01FFFFFF)<<6);
				}
				if(opcodes[code][1]=="AB"){
					return code | (a<<15) | (( b &0x1FF) << 6);
				}
				if(opcodes[code][1]=="K"){
					var s=this.strings.indexOf(a);
					if(s===-1){
						s=this.strings.length;
						this.strings.push(a);
					}
					return code | (s<<6);
				}
				if(opcodes[code][1]=="N"){
					var n=this.numbers.indexOf(a);
					if(n===-1){
						s=this.numbers.length;
						this.numbers.push(a);
					}
					return code | (n<<6);
				}
			}
			
			parseInstruction(op){

				const opcode=this.getOpcodes()[op&0x3f];
				
				if(opcode[1]=="NONE"){
					return opcode[0];
				}
				if(opcode[1]=="U" || opcode[1]=="L"){
					var u=op>>>6;
					return opcode[0]+" "+u;
				}
				if(opcode[1]=="S" || opcode[1]=="J"){
					var s=(op>>>6)-0x01FFFFFF;
					return opcode[0]+" "+s;
				}
				if(opcode[1]=="AB"){
					var a=op>>>15;
					var b=(op>>>6)&&0x1FF;
					return opcode[0]+" "+a+" "+b;
				}
				if(opcode[1]=="K"){
					var k=this.strings[op>>>6];
					return opcode[0]+" "+k;
				}
				if(opcode[1]=="N"){
					var n=this.numbers[op>>>6];
					return opcode[0]+" "+n;
				}
				return opcode[0];
			}
			
			getOpcodes(){
				return [
					["END", "NONE"],
					["RETURN", "U"],
					["CALL", "AB"],
					["TAILCALL", "AB"],
					["PUSHNIL", "U"],
					["POP", "U"],
					["PUSHINT", "S"],
					["PUSHSTRING", "K"],
					["PUSHNUM", "N"],
					["PUSHNEGNUM", "N"],
					["PUSHUPVALUE", "U"],
					["GETLOCAL", "L"],
					["GETGLOBAL", "K"],
					["GETTABLE", "NONE"],
					["GETDOTTED", "K"],
					["GETINDEXED", "L"],
					["PUSHSELF", "K"],
					["CREATETABLE", "U"],
					["SETLOCAL", "L"],
					["SETGLOBAL", "K"],
					["SETTABLE", "AB"],
					["SETLIST", "AB"],
					["SETMAP", "U"],
					["ADD", "NONE"],
					["ADDI", "S"],
					["SUB", "NONE"],
					["MULT", "NONE"],
					["DIV", "NONE"],
					["POW", "NONE"],
					["CONCAT", "U"],
					["MINUS", "NONE"],
					["NOT", "NONE"],
					["JMPNE", "J"],
					["JMPEQ", "J"],
					["JMPLT", "J"],
					["JMPLE", "J"],
					["JMPGT", "J"],
					["JMPGE", "J"],
					["JMPT", "J"],
					["JMPF", "J"],
					["JMPONT", "J"],
					["JMPONF", "J"],
					["JMP", "J"],
					["PUSHNILJMP", "NONE"],
					["FORPREP", "J"],
					["FORLOOP", "J"],
					["LFORPREP", "J"],
					["LFORLOOP", "J"],
					["CLOSURE", "AB"],
				];
			}
			
			getSize(){
				var size=63;

				size+=this.instructions.length*4;
				size+=this.numbers.length*8;
				size+=this.strings.length*4;

				for(var s of this.strings){
					size+=s.length+1;
				}

				return size;
			}
			
			toBuffer(){
				const b=new ArrayBuffer(this.getSize());
				const data=new DataView(b);
				
				data.setUint32(0, 0x61754c1b, true);
				
				data.setUint8(4, 0x40, true);
				data.setUint8(5, 1, true);
				data.setUint8(6, 4, true);
				data.setUint8(7, 4, true);
				data.setUint8(8, 4, true);
				data.setUint8(9, 32, true);
				data.setUint8(10, 6, true);
				data.setUint8(11, 9, true);
				data.setUint8(12, 8, true);
				
				data.setFloat64(13, 3.14159265358979323846E8, true);


				data.setUint32(21, 1, true);
				data.setUint8(25, 0, true);

				data.setUint32(26, 0, true);
				data.setUint32(30, 0, true);
				data.setUint8(34, 0, true);
				data.setUint32(35, this.maxStack, true);
				
				data.setUint32(39, 0, true);
				
				data.setUint32(43, 0, true);
				
				data.setUint32(47, this.strings.length, true);
				
				var offset=51;
				
				for(var s of this.strings){
					data.setUint32(offset, s.length+1, true);
					offset+=4;
					for(var i=0; i<s.length; i++){
						data.setUint8(offset++, s.charCodeAt(i), true);
					}
					data.setUint8(offset++, 0, true);
				}

				data.setUint32(offset, this.numbers.length, true);
				offset+=4;
				
				for(var n of this.numbers){
					data.setFloat64(offset, n, true);
					offset+=8;
				}
				
				data.setUint32(offset, 0, true);
				offset+=4;
				
				data.setUint32(offset, this.instructions.length, true);
				offset+=4;
				
				for(var ins of this.instructions){
					data.setUint32(offset, ins, true);
					offset+=4;
				}
				return b;
			}
			
		}

		class File{
			constructor(buffer){
				this.buffer=buffer;
				this.data=new DataView(buffer);
			}

			read4(offset){
				return this.data.getUint32(offset, false);
			}

			read2(offset){
				return this.data.getUint16(offset, false);
			}

			read(offset){
				return this.data.getUint8(offset, false);
			}

			write4(offset, value){
				if(value<0){
					this.data.setInt32(offset, value, false);
				}else{
					this.data.setUint32(offset, value, false);
				}
			}

			write2(offset, value){
				if(value<0){
					this.data.setInt16(offset, value, false);
				}else{
					this.data.setUint16(offset, value, false);
				}
			}

			write(offset, value){
				if(value<0){
					this.data.setInt8(offset, value, false);
				}else{
					this.data.setUint8(offset, value, false);
				}
			}

			replace(buffer){
				this.buffer=buffer;
				this.data=new DataView(buffer);
			}

			decompressSKASC(){
				if(this.read4(0)==0x2a534b5f && this.read4(4)==0x4153432a){//*SK_ASC*
					return decompress(new Uint8Array(this.buffer));
				}else{
					throw "Incorrect header in SK_ASC";
				}
			}

			asGPK(){
				return new GPK(this.buffer);
			}

			asNPC(){
				return new NPC(this.buffer);
			}

		}

		class FST{
			constructor(buffer, offset, size){

				const raw=new DataView(buffer);

				var eOffset=0;

				var entries=[];

				var loadEntry={name:"loading", type:"dir", entries:[], parent:null, next:1};

				var curDir=loadEntry;

				while(eOffset<size){
					while(curDir && entries.length>=curDir.next){
						curDir=curDir.parent;
					}

					if(curDir==null){
						break;
					}

					var first=raw.getUint32(offset+eOffset, false);
					var type=(first &0xFF000000)>>24;
					var str=first&0xFFFFFF;

					var offsetOrParent=raw.getUint32(offset+eOffset+4, false);
					var fileLength=raw.getUint32(offset+eOffset+8, false);

					if(type==0){
						var entry={name: str, type: "file", offset: offsetOrParent, len: fileLength, file: null};
						curDir.entries.push(entry);
						entries.push(entry)
					}else if(type==1){
						var entry={name: str, type: "dir", entries:[], parent: entries.length==0 ? null : entries[offsetOrParent], next:fileLength};

						curDir.entries.push(entry);
						entries.push(entry);
						curDir=entry;
					}else{
						throw("Unexpected file type in FST");
					}

					eOffset+=12;
				}

				if(eOffset>=size){
					throw("Unexected FST end");
				}

				for(var ent in entries){
					var index=entries[ent].name;
					var str="";
					var cur=0;
					while((cur=raw.getUint8(offset+eOffset+index, false))!=0){
						str+=String.fromCharCode(cur);
						index++;
					}
					entries[ent].name=str;

					if(entries[ent].type=="file"){
						entries[ent].file=new File(buffer.slice(entries[ent].offset, entries[ent].offset+entries[ent].len));

						entries[ent].align=32*1024;

						while(entries[ent].offset % entries[ent].align!=0){
							entries[ent].align/=2;
						}
					}
				}

				this.root=loadEntry.entries[0];
				this.root.name="";
			}

			getFrom(name, entry){
				if(typeof(name)=="string"){
					name=name.split("/");
				}
				for(var ent of entry.entries){
					if(ent.name==name[0]){
						if(name.length==1){
							return ent;
						}else if(ent.type=="dir"){
							return this.getFrom(name.slice(1), ent);
						}else{
							throw("Tried to traverse into file "+ name[0]);
						}
					}
				}
				throw("Could not find file");
			}

			getEntry(name){
				if(typeof(name)=="string" && name[0]=="/"){
					name=name.substr(1);
				}
				return this.getFrom(name, this.root);
			}

			getFile(name){
				var e=this.getEntry(name);
				if(e.type=="dir"){
					throw("Tried to getFile for directory"+name);
				}
				return e.file;
			}

			countNestedEntries(entry){
				if(entry.type == "file"){
					return 1;
				}
				var count=1;

				for(var ent of entry.entries){
					count+=this.countNestedEntries(ent);
				}
				return count;
			}

			getNestedStringLength(entry){
				var count=entry.name.length+1;
				if(entry.type=="file"){
					return count;
				}
				for(var ent of entry.entries){
					count+=this.getNestedStringLength(ent);
				}
				return count;
			}

			getSize(){
				var size=this.countNestedEntries(this.root)*12;
				var stringSize=this.getNestedStringLength(this.root);

				return size+stringSize;
			}

			writeEntryToBuffer(buffer, offset, entryOffset, stringsBase, stringsOffset, fileOffset, parentOffset, entry){
				var initial=entryOffset;
				var data=new DataView(buffer);

				var filesWritten=[];

				var first=stringsOffset+((entry.type=="dir" ? 1 : 0)<<24);
				data.setUint32(offset+(entryOffset*12), first, false);
				writeString(buffer, entry.name, offset+stringsBase+stringsOffset);
				stringsOffset+=entry.name.length+1;

				if(entry.type=="file"){

					var existing=null;

					for(var check of filesWritten){
						if(check[0]===entry.file.buffer && check[1] % entry.align==0){
							existing=check;
							break;
						}
					}

					if(existing){
						data.setUint32(offset+(entryOffset*12)+4, existing[1], false);
						data.setUint32(offset+(entryOffset*12)+8, existing[2], false);
					}else{

						if(fileOffset % entry.align!=0){
							fileOffset=fileOffset+entry.align - (fileOffset % entry.align);
						}

						data.setUint32(offset+(entryOffset*12)+4, fileOffset, false);
						data.setUint32(offset+(entryOffset*12)+8, entry.file.buffer.byteLength, false);

						writeBuffer(entry.file.buffer, buffer, fileOffset);

						filesWritten.push([entry.file.buffer, fileOffset, entry.file.buffer.byteLength]);

						fileOffset+=entry.file.buffer.byteLength;
					}

					entryOffset++;
				}else{
					data.setUint32(offset+(entryOffset*12)+4, parentOffset, false);

					entryOffset++;
					for(var ent of entry.entries){
						var n=this.writeEntryToBuffer(buffer, offset, entryOffset, stringsBase, stringsOffset, fileOffset, initial, ent);
						entryOffset=n[0];
						stringsOffset=n[1];
						fileOffset=n[2];
					}

					data.setUint32(offset+(initial*12)+8, entryOffset, false);
				}
				return [entryOffset, stringsOffset, fileOffset];
			}

			writeToBuffer(buffer, offset){
				var n=this.writeEntryToBuffer(buffer, offset, 0, this.countNestedEntries(this.root)*12, 0, offset+this.getSize(), 0, this.root);
				return n[2];
			}

		}

		class Header{
			constructor(buffer){

				var raw=new DataView(buffer);

				if(raw.getUint32(0x1c, false)!=0xc2339f3d){
					throw("Bad magic number");
				}

				this.apploaderSize=raw.getUint32(0x2440+0x14, false);

				this.buffer=buffer.slice(0, 0x2440+this.apploaderSize);
				this.data=new DataView(this.buffer);
				this.dolOffset=this.data.getUint32(0x420, false);
				this.fstOffset=this.data.getUint32(0x424, false);
				this.fstSize=this.data.getUint32(0x428, false);
			}

			rebuild(iso){

				this.dolOffset=this.buffer.byteLength;
				this.data.setUint32(0x420, this.dolOffset, false);

				this.fstOffset=this.dolOffset+iso.dol.getSize();
				this.data.setUint32(0x424, this.fstOffset, false);

				this.fstSize=iso.fst.getSize();
				this.data.setUint32(0x428, this.fstSize, false);
				this.data.setUint32(0x42C, this.fstSize, false);
			}

			writeToBuffer(buffer, offset){
				writeBuffer(this.buffer, buffer, offset);
				return offset+this.dolOffset;
			}
		}

		class GCISO {

			constructor(buffer){

				this.imageSize=1459978240;

				if(buffer.byteLength!=this.imageSize){
					console.log("Bad file size, are you sure this is a gamecube iso?");
				}

				this.header=new Header(buffer);

				this.dol=new DOL(buffer.slice(this.header.dolOffset));

				this.fst=new FST(buffer, this.header.fstOffset, this.header.fstSize);

			}

			toBuffer(){

				var ret=new ArrayBuffer(this.imageSize);
				this.header.rebuild(this);
				var c=this.header.writeToBuffer(ret, 0);
				c=this.dol.writeToBuffer(ret, c);

				c=this.fst.writeToBuffer(ret, c);
				console.log("Free space: "+(this.imageSize-c));
				return ret;
			}
		}

		var iso=null;
		var manualMode=false;

		input.addEventListener('change', () => {
			let files = input.files;

			if (files.length == 0) return;

			const file = files[0];

			if(document.getElementById("seed").value===""){
				let u = new Uint32Array(1);
				window.crypto.getRandomValues(u);
				seed=u[0];
			}else{
				seed=parseInt(document.getElementById("seed").value, 16);
			}

			Math.random=mulberry32(seed);

			let reader = new FileReader();
			displayMessage("Loading");
			reader.onload = (e) => {
				const file = e.target.result;

				displayMessage("Analyzing");
				window.setTimeout(function(){
					var niso=new GCISO(file);

					if(manualMode){
						iso=niso;
						displayMessage("Ready");
					}else{
						displayMessage("Patching");
						window.setTimeout(function(){
							prepare(niso);
							bypassCompression(niso, function(){
								if(document.getElementById("text_control").checked){
									roomTextShuffle(niso);
								}
								if(document.getElementById("enemy_control").checked){
									randomizeEnemies(niso, []);//[null, null, null, [[0, 12]]],//anthony
									// [null, null, null, [18, 12]],//karim
									// null,[],//lindsey
									//  );
								}
								if(document.getElementById("rune_control").checked){
									randomizeRunes(niso);
								}
								displayMessage("Rebuilding");
								window.setTimeout(function(){
									var buf=niso.toBuffer();
									displayMessage("Preparing download");
									download(buf,  "ED.random."+(seed.toString(16))+".iso");
								}, 1);
							});
						}, 1);
					}
				}, 1);
			};

			reader.onerror = (e) => alert(e.target.error.name);

			reader.readAsArrayBuffer(file);
		});

		function decompressAll(dir){
			for(var entry of dir.entries){
				if(entry.type=="dir"){
					decompressAll(entry);
				}else if(entry.type=="file"){
					var file=entry.file;
					if(file.read4(0)==0x2a534b5f && file.read4(4)==0x4153432a){//*SK_ASC*
						console.log("Decompressing "+entry.name);
						file.replace(file.decompressSKASC());
					}
				}
			}
		}

		function mulberry32(a) {
		    return function() {
		      var t = a += 0x6D2B79F5;
		      t = Math.imul(t ^ t >>> 15, t | 1);
		      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
		      return ((t ^ t >>> 14) >>> 0) / 4294967296;
		    }
		}

		function displayMessage(message){
			document.getElementById("message").innerHTML=message;
		}

		function prepare(iso){
			iso.dol.prepareInjectionSection(0x802fd8e0);
		}

		function loadAsset(url, onLoad){
			var xhr = new XMLHttpRequest();

			xhr.addEventListener('load', function(){
				if (xhr.status == 200){
					var fileReader = new FileReader();
					fileReader.onload = function(event) {
					    arrayBuffer = event.target.result;

						onLoad(event.target.result);
					};
					fileReader.readAsArrayBuffer(xhr.response);
				}else{
					console.log("Could not load "+url);
				}
			});
			xhr.addEventListener('error', function(e){
				console.log("Error when loading "+url);
				console.log(e);
			});
			xhr.open('GET', url);
			xhr.responseType = 'blob';
			xhr.send(null);
		}

		function bypassCompression(iso, continuation){

			loadAsset("./compressionBypass.bin", function(code){
				iso.dol.inject(0x80147e4c, code, [0x14, 0x34, 0x64, 0x9c, 0xb0]);
				if(continuation){
					continuation();
				}
			});

		}

		function collectNpcTypes(iso){
			var res=[];

			var i=0;
			while(i<14){
				if(i==12){
					i++;
					continue;
				}
				var filename="Npcs"+i+".npc";

				var f=iso.fst.getFile(filename);

				var c=f.read4(4);

				var j=0;
				while(j<c){
					var type=f.read4(0x44+j*0x28).toString(16);

					if(!res[type]){
						res[type]=0;
					}
					res[type]++;

					j++;
				}
				i++;
			}
			return res;
		}

		function collectNpcTypesLevel(iso, level){
			var filename="Npcs"+level+".npc";
			var res=[]
			var f=iso.fst.getFile(filename);

			var c=f.read4(4);

			var j=0;
			console.log(c);
			while(j<c){
				var type=f.read4(0x44+j*0x28).toString(16);

				if(!res[type]){
					res[type]=0;
				}
				res[type]++;

				j++;
			}
			return res;
		}

		function randomizeEnemies(iso, skipList){

			var pious=iso.fst.getFile("Npcs1.npc").asNPC();
			var lindsey=iso.fst.getFile("Npcs6.npc").asNPC();
			var karim=iso.fst.getFile("Npcs4.npc").asNPC();

			const buildTemplateFromStatic = (e)=> {
				return [new Uint8Array(e.slice(0x18, 0x18+0x4)), new Uint8Array(e.slice(0x20, 0x20+0x2))];
			};

			const buildTemplateFromDynamic = (e, i)=> {
				return [new Uint8Array(e.slice(0x18+i*6, 0x18+i*6+4)), new Uint8Array(e.slice(0x1c+i*6, 0x1c+i*6+2))];
			};

			var templates=[
				buildTemplateFromStatic(pious.entries[0][0]),//m zombie,
				buildTemplateFromStatic(lindsey.entries[0][0xe]), //x zombie
				buildTemplateFromStatic(lindsey.entries[0][0x13]),//u zombie
				buildTemplateFromStatic(lindsey.entries[0][9]),//c zombie
				buildTemplateFromDynamic(karim.entries[3][0], 0),//x horror
				buildTemplateFromDynamic(karim.entries[3][0], 2),//u horror
				buildTemplateFromDynamic(karim.entries[3][0], 1),//c horror
				buildTemplateFromDynamic(lindsey.entries[3][15], 2),//x trapper
				buildTemplateFromDynamic(lindsey.entries[3][15], 1),//u trapper
				buildTemplateFromDynamic(lindsey.entries[3][15], 0),//c trapper
			];

			const runeSafe=7;

			var candidates=[];
			for(var temp of templates){
				candidates.push(new DataView(temp[0].buffer).getUint16(0, false));
			}

			candidates=candidates.slice(0, 7);//Workaround for trapper based crashes

			var i=0;
			while(i<14){
				if(i==12){
					i++;
					continue;
				}
				var file=iso.fst.getFile("Npcs"+i+".npc");

				var npcs=file.asNPC();

				var c=npcs.entries[0].length;

				var j=0;
				while(j<c){
					var type=new DataView(npcs.entries[0][j]).getUint16(0x18, false);

					if(candidates.indexOf(type)!==-1 && (!skipList[i] || !skipList[i][0] || skipList[i].indexOf(j)===-1) ){
						var b=new Uint8Array(npcs.entries[0][j]);
						var maxIndex=templates.length;

						var script=new DataView(npcs.entries[0][j]).getUint16(0x1c, false);

						if(script!=0xFFFF){
							maxIndex=runeSafe;
						}
						var rand=Math.floor(Math.random()*maxIndex);
						b.set(templates[rand][0], 0x18);
						b.set(templates[rand][1], 0x20);
					}
					j++;
				}

				c=npcs.entries[3].length;

				j=0;
				while(j<c){

					var type=new DataView(npcs.entries[3][j]).getUint16(0x18, false);
					if(candidates.indexOf(type)!==-1 && (!skipList[i] || !skipList[i][3] || skipList[i][3].indexOf(j)===-1) ){
						var b=new Uint8Array(npcs.entries[3][j]);
						var maxIndex=templates.length;

						var script=new DataView(npcs.entries[3][j]).getUint16(0x2a, false);

						if(script!=0xFFFF){
							maxIndex=runeSafe;
						}

						var rand=Math.floor(Math.random()*maxIndex);
						b.set(templates[rand][0], 0x18);
						b.set(templates[rand][1], 0x1c);
						rand=Math.floor(Math.random()*maxIndex);
						b.set(templates[rand][0], 0x1e);
						b.set(templates[rand][1], 0x22);
						rand=Math.floor(Math.random()*maxIndex);
						b.set(templates[rand][0], 0x24);
						b.set(templates[rand][1], 0x28);
					}

					j++;
				}

				file.replace(npcs.toBuffer());

				i++;
			}
		}

		function roomTextShuffle(iso){

			var gpks=[];
			var newGpks=[];
			var entries=[];
			var pools=[];
			var cmps=[];

			var i=0;
			while(i<14){
				var filename="RmTxt"+("00"+i).slice(-2)+".cmp";

				var cmp=iso.fst.getFile(filename);
				cmp.replace(cmp.decompressSKASC());

				cmps[i]=cmp;

				gpks[i]=new GPK(cmp.buffer);
				newGpks[i]=new GPK();

				for(var fi in gpks[i].entries){
					if(gpks[i].entries[fi]){
						for(var si in gpks[i].entries[fi]){
							if(gpks[i].entries[fi][si]){
								var d=new DataView(gpks[i].entries[fi][si]);
								var special=d.getUint32(0, false);
								if(!pools[special]){
									pools[special]=[];
								}
								if(!entries[fi]){
									entries[fi]=[];
								}
								if(!entries[fi][si]){
									entries[fi][si]=[];
								}
								pools[special].push([fi, si]);
								entries[fi][si].push(i);
							}
						}
					}
				}
				i++;
			}

			for(var special in pools){
				var pc=pools[special].slice(0);
				pc.sort(() => { return Math.random()-0.5;});

				for(var rIndex in pools[special]){
					var source=pc[rIndex];
					var dest=pools[special][rIndex];

					var sourceFi=source[0];
					var sourceSi=source[1];

					var destFi=dest[0];
					var destSi=dest[1];

					var data=gpks[entries[sourceFi][sourceSi][0]].entries[sourceFi][sourceSi];

					for(var de of entries[destFi][destSi]){
						if(!newGpks[de].entries[destFi]){
							newGpks[de].entries[destFi]=[];
						}
						newGpks[de].entries[destFi][destSi]=data;
					}

				}
			}
			for(var file in cmps){
				cmps[file].replace(newGpks[file].toBuffer());
			}

		}
		
		function replaceScript(iso, script, lua){
			var i=0;
			while(i<14){
				if(i==12){
					i++;
					continue;
				}

				var f=iso.fst.getFile("ScrLvl"+("00"+i).slice(-2)+".gpk");
				var g=f.asGPK();

				if(g.entries[script]){
					g.entries[script]=lua;
				}

				f.replace(g.toBuffer());
				i++;
			}
		}
		
		function randomizeRunes(iso){
			var runeScripts=[[1367, 1], //128
							 [1363, 25], //8
							 [1360, 5], //1
							 [1361, 5], //2
							 [1362, 5], //4
							 [1366, 1], //64
							 [1372, 1], //4096
							 [1371, 1], //2048
							 [1364, 1], //16
							 [1369, 1], //512
							 [1373, 1], //8192
							 [1365, 1], //32
							 [1370, 1], //1024
							 [1368, 1]]; //256
							 
			var rand=[];
			
			for(var i=0; i<14; i++){
				rand.push(1<<i);
			}
			
			rand.sort((e)=>{return Math.random()-0.5;});
			
			const source=iso.fst.getFile("ScrLvl03.gpk").asGPK();
			
			var i=0;
			for(var script of runeScripts){
				const lua=new LUA(source.entries[script[0]]);
				lua.instructions[script[1]]=lua.buildInstruction("PUSHINT", rand[i++]);
				replaceScript(iso, script[0], lua.toBuffer());
			}
			
		}

		function textLookup(file, i1, i2){
			if(file.read4(4)!=0x6b5){
				throw "Doesn't look like an archive file, did you forget to decompress?";
			}

			if(file.read4(0)<=i1){
				throw "First index out of bounds";
			}

			var iOffset=file.read4(8+i1*8);
			if(iOffset==0){
				throw "First index empty";
			}

			if(file.read4(iOffset+4)!=0xfb90){
				throw "Not a text archive";
			}

			if(file.read4(iOffset)<=i2){
				throw "Second index out of bounds";
			}

			var eOffset=file.read4(iOffset+8+i2*8);
			var size=file.read4(iOffset+12+i2*8);
			if(eOffset==0 || size==0){
				throw "Entry empty";
			}

			var buf=file.buffer.slice(iOffset+eOffset+4, iOffset+eOffset+size+4);

			return decompressText(new Uint8Array(buf), size-4);
		}

		function stripFMV(iso){
			const changeTo=0;

			const sourceA=iso.fst.getFile("fmv/fmv"+(("0000" + changeTo).slice(-4))+".aud");
			const sourceH=iso.fst.getFile("fmv/fmv"+(("0000" + changeTo).slice(-4))+".h4m");

			var i=1;

			while(i<64){
				try{
					var fileA=iso.fst.getFile("fmv/fmv"+(("0000" + i).slice(-4))+".aud");
					fileA.replace(sourceA.buffer);
				}catch(err){}//TODO proper fs errors

				try{
					var fileH=iso.fst.getFile("fmv/fmv"+(("0000" + i).slice(-4))+".h4m");
					fileH.replace(sourceH.buffer);
				}catch(err){}
				i++;
			}
		}

    </script>
    <script src="./skasc.js"></script>
</body>

</html>
